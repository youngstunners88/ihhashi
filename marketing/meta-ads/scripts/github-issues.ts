#!/usr/bin/env bun
/**
 * GitHub Issues Integration
 * 
 * Creates GitHub issues from ad performance findings.
 * This allows the system to constantly improve based on tracked issues.
 * 
 * Usage:
 *   bun github-issues.ts --type fatigue --title "Ad dying" --body "Frequency > 4"
 *   bun github-issues.ts --from-file ./findings.json
 */

const GITHUB_API = "https://api.github.com";
const REPO_OWNER = "youngstunners88";
const REPO_NAME = "ihhashi";

interface IssuePayload {
  title: string;
  body: string;
  labels: string[];
}

async function createIssue(payload: IssuePayload, token: string): Promise<number> {
  const response = await fetch(
    `${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/issues`,
    {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
        "Content-Type": "application/json",
        "User-Agent": "iHhashi-Meta-Ads",
      },
      body: JSON.stringify(payload),
    }
  );

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`GitHub API error: ${error}`);
  }

  const data = await response.json();
  return data.number;
}

async function listIssues(labels: string[], token: string): Promise<any[]> {
  const labelQuery = labels.join(",");
  const response = await fetch(
    `${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/issues?labels=${labelQuery}&state=open`,
    {
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
        "User-Agent": "iHhashi-Meta-Ads",
      },
    }
  );

  if (!response.ok) {
    throw new Error(`GitHub API error: ${await response.text()}`);
  }

  return response.json();
}

async function closeIssue(issueNumber: number, token: string): Promise<void> {
  await fetch(
    `${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/issues/${issueNumber}`,
    {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
        "Content-Type": "application/json",
        "User-Agent": "iHhashi-Meta-Ads",
      },
      body: JSON.stringify({ state: "closed" }),
    }
  );
}

// Label definitions
const LABELS = {
  health: "ads-health",
  fatigue: "ads-fatigue",
  budget: "ads-budget",
  copy: "ads-copy",
  critical: "ads-critical",
} as const;

function getLabelsForType(type: keyof typeof LABELS): string[] {
  const labels = ["ads"];
  if (LABELS[type]) {
    labels.push(LABELS[type]);
  }
  return labels;
}

// Format findings as issue body
function formatFindings(findings: {
  type: string;
  campaignId?: string;
  campaignName?: string;
  metric?: string;
  value?: number;
  threshold?: number;
  recommendation?: string;
  timestamp?: string;
}): string {
  const lines = [
    `## Ad Performance Finding`,
    ``,
    `**Type:** ${findings.type}`,
    `**Detected:** ${findings.timestamp || new Date().toISOString()}`,
    ``,
  ];

  if (findings.campaignName) {
    lines.push(`**Campaign:** ${findings.campaignName}`);
  }
  if (findings.campaignId) {
    lines.push(`**Campaign ID:** \`${findings.campaignId}\``);
  }
  if (findings.metric && findings.value !== undefined) {
    lines.push(`**Metric:** ${findings.metric} = ${findings.value}`);
  }
  if (findings.threshold !== undefined) {
    lines.push(`**Threshold:** ${findings.threshold}`);
  }

  if (findings.recommendation) {
    lines.push(``, `### Recommendation`, ``, findings.recommendation);
  }

  lines.push(``, `---`, `*Auto-generated by iHhashi Meta Ads Automation*`);

  return lines.join("\n");
}

// CLI handling
async function run() {
  const args = process.argv.slice(2);
  const token = process.env.GITHUB_TOKEN;

  if (!token) {
    console.error("Error: GITHUB_TOKEN not set");
    console.error("Get a token from: https://github.com/settings/tokens");
    console.error("Required scopes: repo");
    process.exit(1);
  }

  // Parse arguments
  const typeIndex = args.indexOf("--type");
  const titleIndex = args.indexOf("--title");
  const bodyIndex = args.indexOf("--body");
  const fileIndex = args.indexOf("--from-file");
  const listIndex = args.indexOf("--list");
  const closeIndex = args.indexOf("--close");

  // List issues
  if (listIndex >= 0) {
    const labels = args.slice(listIndex + 1);
    const issues = await listIssues(labels.length > 0 ? labels : ["ads"], token);
    console.log(`\nüìã Open Ad Issues (${issues.length}):\n`);
    for (const issue of issues) {
      console.log(`  #${issue.number} - ${issue.title}`);
      console.log(`  Labels: ${issue.labels.map((l: any) => l.name).join(", ")}`);
      console.log(`  ${issue.html_url}\n`);
    }
    return;
  }

  // Close issue
  if (closeIndex >= 0) {
    const issueNumber = parseInt(args[closeIndex + 1]);
    await closeIssue(issueNumber, token);
    console.log(`‚úÖ Closed issue #${issueNumber}`);
    return;
  }

  // Create from file
  if (fileIndex >= 0) {
    const filePath = args[fileIndex + 1];
    const { default: findings } = await import(filePath, { assert: { type: "json" } });
    
    const issueNumber = await createIssue(
      {
        title: findings.title || `${findings.type}: ${findings.campaignName || "Unknown"}`,
        body: formatFindings(findings),
        labels: getLabelsForType(findings.type),
      },
      token
    );
    
    console.log(`‚úÖ Created issue #${issueNumber}`);
    console.log(`   https://github.com/${REPO_OWNER}/${REPO_NAME}/issues/${issueNumber}`);
    return;
  }

  // Create from args
  if (typeIndex >= 0 && titleIndex >= 0) {
    const type = args[typeIndex + 1] as keyof typeof LABELS;
    const title = args[titleIndex + 1];
    const body = bodyIndex >= 0 ? args[bodyIndex + 1] : "";

    const issueNumber = await createIssue(
      {
        title,
        body: body || formatFindings({ type }),
        labels: getLabelsForType(type),
      },
      token
    );

    console.log(`‚úÖ Created issue #${issueNumber}`);
    console.log(`   https://github.com/${REPO_OWNER}/${REPO_NAME}/issues/${issueNumber}`);
    return;
  }

  // Show usage
  console.log(`
Usage:
  Create issue:
    bun github-issues.ts --type <type> --title "Title" --body "Body"
  
  Create from file:
    bun github-issues.ts --from-file ./findings.json
  
  List issues:
    bun github-issues.ts --list [label1,label2,...]
  
  Close issue:
    bun github-issues.ts --close <issue-number>

Issue Types:
  health    - Health check findings
  fatigue   - Fatigue detection alerts
  budget    - Budget optimization suggestions
  copy      - Copy generation requests
  critical  - Requires immediate attention

Required:
  GITHUB_TOKEN environment variable
`);
}

run().catch((error) => {
  console.error("‚ùå Error:", error.message);
  process.exit(1);
});
